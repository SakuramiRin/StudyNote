    【  封装  继承  多态 】

    找到对象就找到了功能！
    --------------------
找对象，造对象，用对象，维护对象的关系

面向对象是一种思考的思想，是相对于面向过程而言的，它基于面向过程
  面向过程强调的是功能行为
  面向对象将功能封装进对象，强调了功能的对象。

  事物拿到了，功能也就拿到了

类和对象的关系
  类：对现实生活中事物的描述   描述事物其实就是在描述事物的属性和行为
      属性对应类中的【变量】，行为对应类中的【函数】【方法】 ---->属性和行为共同称为类中的成员
                    成员变量              成员方法
  对象：就是这类事物实实在在存在的个体

  Class c = new Class();
    操作对象的方式  对象.对象成员

          任何类中都能创建主函数，且可以在本类中建立本类对象

  ------------------------------------
  映射到java中，描述的就是class定义的类
  具体对象就是对应java在堆内存中用new建立的实体


成员变量和局部变量
  作用范围：成员变量作用于整个类中。
          局部变量作用于函数或者语句中。
  内存位置：成员变量 堆内存中，且因为对象存在才在内存中存在
          局部变量  栈内存

-----------------------------------------------------
匿名对象
  当对象方法仅调用一次  new Class().function;
  匿名对象可以作为实际参数进行传递    function(new Class());

-------------------------------------------------------
内部类
  将一个类定义在另一个类中
  特点：
    内部类可直接访问外部类中的成员，包括私有
    外部访内部需要创建对象
    在再一个类中调用内部类中的成员需要 外部类.内部类  = new 外部类对象().内部类对象();
    内部类可以被私有所修饰

    针对存在成员变量同名情况，想要内部类调用外部类的成员变量需要指明外部类.this
    class ClassOut{
      private int x = 3;
        class ClassIn{
          int x = 4;
            void function(){
              int x =5;
                syso(ClassOut.this.x);
            }
        }
    }
      ------------
      静态内部类
        基本都是被private所修饰，对外提供访问接口，new一个内部类对象
        内部类可以实现接口，或者继承

        内部类被static修饰后，满足访问规则，当内部类中定义了静态成员，改内部类必须也是static的；外部类中的静态方法访问的内部类必须是静态的


        其他类访问静态内部类中的非静态成员
          new ClassOut.ClassIn().function(); 内部类对象调用function方法
        其他类访问静态内部类中的静态成员
          ClassOut.ClassIn.fuction();

          因为只有在成员位置时，内部类才能被static，private修饰，所以当内部类出现在成员方法的方法体中时，不能被修饰
          内部方法体中的内部类需要访问方法体中的变量(即局部变量)时，局部变量需要定义为final!
      ----------
      匿名内部类
        其实就是内部类的简写模式，匿名子类对象-->带内容的对象
        简化书写，覆盖方法(一般内部不超过两个)

        前提：内部类必须是继承抽象类或者实现接口
        new 父类(){括号里的全是子类}

        格式：new父类或者接口(){定义的子类内容}
          在调用一个形参是接口类型对象的方法(函数)时，如果该接口中的方法较少，就可以使用匿名内部类
          方法.(new 接口(){重写方法});

        class ClassOut{
          int x = 3;

          public void function(){
            new 继承的父类或实现的接口(){
              重写该重写的方法
            }.方法 //调用该方法
          }
        }

        可以存在
        ClassFu cf = new ClassFu(){
          重写 父类方法
          也可以定义子类特有方法
        }
        但此时的cf是不能调用子类特有的方法的

        特别的，哪怕只是想调用一个普通的，没有继承或实现的方法，也可以通过new Object(){
          定义方法体
        }.方法()； 也是可以的
