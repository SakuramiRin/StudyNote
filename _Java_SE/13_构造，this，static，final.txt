构造函数：给特定对象【初始化】运行一次--->堆内存建立的时候，需要有初始化动作
          一般方法是对象调用才执行，是给对象添加具备的功能，可被调用多次
  类名{
    代码
  }

  类名相同
  不定义返回值类型
  不return

  默认构造函数：空参空码，类中如果自定义了就消失并被覆盖-->可能出现找不到空参函数。

  多个构造函数以重载形式

  初始化之后的参数修改，依旧需要使用get set 方法

---------------------------------------------------------------
构造代码块：给对象进行【初始化】且优先于构造函数
    {
      代码
    }
            也就是所构造代码块对所有对象，即忽略构造函数的参数进行统一初始化
-----------------------------------------------------------------
this
  用于区分局部变量和成员变量的重名，代表它所在函数所属对象的引用(本类对象)
  -->谁调用代表谁
  该函数内部要调用该函数的对象时，这时用this
    public boolean agecompare(Person p){
      //if (this.age == p.age)
        //return ture;
      return this.age == p.age;
    }
    ……
    boolean result = p1.compare(p2);
    ……

    bleaon result = (new Person(20)).compare(new Person(25));


  this语句
  用于构造函数间进行互相调用
    只能放在构造函数的第一行，因为初始化中还有初始化，就要先进行最最里面的初始化
  this(name)

    Person(String name){  //构造函数1
      this.name = name ;
    }
    Person(String name,int age){  //构造函数2
      //this.name = name;
      this(name);         //调用了上一个构造函数2
      this.age = age;
    }


------------------------------------------------------------
static
  当我们创建很多对象时，可能存在共同数据，将这些共有数据提取出来，谁要用谁就拿出来用，节省内存空间---->特有数据随着对象去存储

    ----->从“堆”内存中解放--->进入方法区(又叫共享区数据区)

  用于修饰成员(成员变量和成员函数)满足
    静态成员变量：当对象中出现共享数据
    静态函数：当功能内部没有访问到非静态数据！！！ --->访问的全是静态变量或者根本就没有访问到变量----> 深入的理解：对象的本质是为了封装数据，将数据分开。那么建立对象没使用数据而只是调用功能那就需要静态------>Class.方法()
    工具类全是静态的方法！！！！！！！！---->强制让该类不能建立对象--->构造函数私有化----->private 类名(){}

  Class{
    static 成员 = 数据;
  }

  主函数中{
    Class class = new Class();
    class.成员
    Class.成员  //两种方法调用到共有成员数据
  }

  特点：
    随类加载而加载消失而消失--->生命周期最长（有利有弊）
      注意：
        静态方法只能访问静态成员
        静态方法中不可以 this,super
    优先于对象的存在：非静态成员随对象加载而加载消失而消失
    被所有对象所共享：存放共同数据
    可以直接被类名所调用：当成员被静态修饰后，除可被对象调用外，还可直接被类名调用---->类名.静态成员

  利处：对对象的共享数据进行单独空间的存储，节省空间。没有必要每一个对象中都存储一份
  	可以直接被类名调用。
  弊端：生命周期过长。
  	  访问出现局限性。(静态虽好，只能访问静态。)


  静态代码块：用于给类进行初始化
    static{
      代码
    }

    特点：随类加载而加载，且高于主函数（用到类才加载，null不加载）执行且只执行一次

    执行顺序：
      public class StaticCode {

      	String st = "成员变量";

      	static{                 //静态代码块
              System.out.println("副类静态");
            }

            StaticCode(){           //空参构造函数
          	  System.out.println("空参构造函数");
            }

            {
          	  System.out.println("构造代码块"+" "+this.st);
            }

            StaticCode(int x){
          	  System.out.println("带参构造函数");
            }

            public static void show(){
          	  System.out.println("show()被调用");
            }
      }
      public class StaticCodeDemo {

      	static{ //静态代码块1
              System.out.println("主类静态1");
            }

      	public static void main(String[] args) {
      		new StaticCode(4); //加载StaticCode 类 执行他类中的静态代码块
              //不new但调用功能show()也会加载
              new StaticCode(); //不再执行！
              System.out.println("主函数语句");
      	}

      	static{ //静态代码块1
              System.out.println("主类静态2");
            }

      }
      --------->主类静态1
                主类静态2
                副类静态
                构造代码块 成员变量
                带参构造函数
                构造代码块 成员变量
                空参构造函数
                主函数语句

    对象被创建的过程：
      堆内存加载---->栈内存加载--->静态成员赋初始值null，0---->静态成员赋已配值显示舒适化---->构造代码块初始化----->构造函数

      --------------------------------------------------
Class class = new Class("String",0);

    1，因为new用到了Class.class.所以会先找到Class.class文件并加载到内存中。
    2，执行该类中的static代码块，如果有的话，给Class.class类进行初始化。
    3，在堆内存中开辟空间，分配内存地址。
    4，在堆内存中建立对象的特有属性。并进行默认初始化。
    5，对属性进行显示初始化。
    6，对对象进行构造代码块初始化。
    7，对对象进行对应的构造函数初始化。
    8，将内存地址付给栈内存中的p变量。


-------------------------------------------------------------------
final
特点：
  可以修饰类，方法，变量
  修饰的类不可被继承
  修饰的方法不可被覆盖
  修饰的变量是一个常量只能被赋值一次
  内部类只能访问被final修饰的局部变量
  
